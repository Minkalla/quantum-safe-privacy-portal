# .env.example for Minkalla Portal Backend
#
# @file .env.example
# @description Template file for environment variables required by the Quantum-Safe Privacy Portal Backend.
# This file provides detailed explanations for each variable and should be copied to a '.env' file
# for local development, with actual secret values inserted. DO NOT COMMIT .env TO GIT!
#
# @author Minkalla
# @license MIT
#
# @remarks
# Adheres to "no regrets" quality by providing exhaustive documentation for environmental configurations.
# Essential for streamlined developer onboarding and consistent local environments.

# --- Application Environment ---
# NODE_ENV: Specifies the application's operating environment.
#   - 'development': For local development. Enables development-specific features (e.g., Swagger UI, detailed logging).
#   - 'production': For live deployments. Optimizes performance and enables production-grade security.
#   - 'test': For running automated tests.
NODE_ENV=development

# PORT: The port number on which the Express server will listen.
#   - For local Docker Compose setup, this maps to the host's port.
#   - For cloud deployments (e.g., AWS Elastic Beanstalk), this is the port the container exposes internally.
PORT=8080

# --- Database Configuration (MongoDB Atlas) ---
# MONGO_URI: The connection string for your MongoDB Atlas database.
#   - MIGRATED FROM DOCKER: This project now uses MongoDB Atlas cloud service instead of local Docker MongoDB.
#   - For MongoDB Atlas: Use the SRV connection string provided by Atlas with your credentials.
#     Format: mongodb+srv://<username>:<password>@<cluster>.mongodb.net/<database>?retryWrites=true&w=majority&appName=<AppName>
#   - The '/portal_dev' part specifies the database name to connect to for development.
#   - Production deployments should use environment variables or secrets management for credentials.
MONGO_URI=mongodb+srv://<username>:<password>@minkallaportalcluster.gqfxskp.mongodb.net/portal_dev?retryWrites=true&w=majority&appName=MinkallaPortalCluster

# --- JWT Authentication Secrets ---
# JWT_ACCESS_SECRET: A strong, random secret key used for signing JWT Access Tokens.
#   - CRITICAL: MUST be a long, complex, random string (e.g., 32+ characters).
#   - NEVER hardcode this in source code.
#   - For production, use a secure secret management service (e.g., AWS Secrets Manager).
JWT_ACCESS_SECRET=your_local_jwt_access_secret

# JWT_REFRESH_SECRET: A strong, random secret key used for signing JWT Refresh Tokens.
#   - CRITICAL: MUST be a long, complex, random string (e.g., 32+ characters).
#   - NEVER hardcode this in source code.
#   - For production, use a secure secret management service.
JWT_REFRESH_SECRET=your_local_jwt_refresh_secret

# --- API Documentation (Swagger UI) ---
# ENABLE_SWAGGER_DOCS: Controls whether the Swagger UI documentation is served.
#   - 'true': Enables /api-docs endpoint (recommended for development and staging).
#   - 'false': Disables /api-docs endpoint (CRITICAL for production security to avoid exposing API internals).
ENABLE_SWAGGER_DOCS=true

# --- Frontend Integration ---
# FRONTEND_URL: The URL of the frontend application. Used for CORS configuration or redirection.
#   - For local development: Typically 'http://localhost:3000' or similar port where your frontend runs.
#   - For production: The live domain of your frontend application.
FRONTEND_URL=http://localhost:3000

# --- Observability & Security ---
# SKIP_SECRETS_MANAGER: Set to 'true' to bypass AWS Secrets Manager in CI/testing environments.
#   - 'false': Use AWS Secrets Manager (default for production/local dev).
#   - 'true': Return dummy secrets (for CI or local testing only).
SKIP_SECRETS_MANAGER=false

# Add any additional variables required for local Docker Compose development below.
# These should match those passed in the 'env' block of .github/workflows/backend.yml.
#
# Example:
AWS_REGION=us-east-1
# AWS_ACCESS_KEY_ID=dummy
# AWS_SECRET_ACCESS_KEY=dummy

# --- PQC Feature Flags Configuration ---
# PQC_KEY_GENERATION_ENABLED: Enable PQC key generation using Kyber-768
#   - 'true': Enable PQC key generation for users in rollout percentage
#   - 'false': Use classical key generation (default for safety)
PQC_KEY_GENERATION_ENABLED=false

# PQC_KEY_GENERATION_PERCENTAGE: Percentage of users to enable PQC key generation for
#   - Range: 0-100 (percentage of users based on consistent hash)
#   - 0: No users get PQC key generation (default)
#   - 100: All users get PQC key generation
PQC_KEY_GENERATION_PERCENTAGE=0

# PQC_USER_REGISTRATION_ENABLED: Enable PQC algorithms during user registration
#   - 'true': Enable PQC for new user registrations in rollout percentage
#   - 'false': Use classical algorithms for registration (default for safety)
PQC_USER_REGISTRATION_ENABLED=false

# PQC_USER_REGISTRATION_PERCENTAGE: Percentage of new users to enable PQC registration for
#   - Range: 0-100 (percentage of users based on consistent hash)
#   - 0: No users get PQC registration (default)
#   - 100: All users get PQC registration
PQC_USER_REGISTRATION_PERCENTAGE=0

# PQC_AUTHENTICATION_ENABLED: Enable PQC algorithms for authentication
#   - 'true': Enable PQC for user authentication in rollout percentage
#   - 'false': Use classical authentication (default for safety)
PQC_AUTHENTICATION_ENABLED=false

# PQC_AUTHENTICATION_PERCENTAGE: Percentage of users to enable PQC authentication for
#   - Range: 0-100 (percentage of users based on consistent hash)
#   - 0: No users get PQC authentication (default)
#   - 100: All users get PQC authentication
PQC_AUTHENTICATION_PERCENTAGE=0

# PQC_JWT_SIGNING_ENABLED: Enable PQC digital signatures for JWT tokens using Dilithium-3
#   - 'true': Enable PQC JWT signing for users in rollout percentage
#   - 'false': Use classical JWT signing (default for safety)
PQC_JWT_SIGNING_ENABLED=false

# PQC_JWT_SIGNING_PERCENTAGE: Percentage of users to enable PQC JWT signing for
#   - Range: 0-100 (percentage of users based on consistent hash)
#   - 0: No users get PQC JWT signing (default)
#   - 100: All users get PQC JWT signing
PQC_JWT_SIGNING_PERCENTAGE=0
